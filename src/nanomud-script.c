/*
MudClient - Play muds!
Copyright (C) 2003  Michael D. Hayes.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

/*  NanoMudScript.c
*  Contains all Scripting code and the fun stuff for the client.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#include <winsock.h>
#include <richedit.h>
#include "NanoMud.h"
#include <assert.h>
#include "nanomud-script.h"
//#include <fnmatch.h>

/* XXX NOTICE:
* All functions here must adhere to the same voided format so that they may all do as needed. If one format needs
* to be changed, change the rest, too!
*/
//int unlink (const char *filename);
TR *freetrigger;
CL *freeclass;
PA *freepath;
MC *freemacro;
AL *freealias;
TR *triggerlist;
CL *classlist;
PA *pathlist;
MC *macrolist;
AL *aliaslist;
VR *freevar;
VR *varlist;

char str_emp[1];

cstack **cmd_stack;

enum {
	SC_NORM,
	SC_VAR,
	SC_FUN,
	SC_NONE
} state;
/* for the command interpreter */
struct func_type func_table[] =
{
	{"trigger", handle_triggers
	},

	{"macro", handle_macros
	},
	{"path", handle_path
	},
	{"url", handle_url
	},
	{"open", handle_open
	},
	{"log", handle_log
	},
	{"help", handle_help
	},
	{"capture", handle_capture
	},
	{"script", handle_script
	},
	{"option", handle_option
	},
	{"save", handle_save
	},
	{"class", handle_class
	},
	{
		NULL,NULL
	}
};

void init_scripts(void)
{
	TR *tri;
	DWORD  nstart, nstop;

	cmd_stack = (cstack **)malloc(500 * sizeof(*cmd_stack));
	tri = new_trigger();
	//tri->script = str_dup("%if( %eval( %eval( %secs - %1)/1000/60/60\60), \"+hour\", %if( %eval( %eval( %secs - %1)/1000/60\60) < 10, 0)%eval( %eval( %secs - %1)/1000/60\60):%if( %eval( %eval( %secs - %1)/1000\60) < 10, 0)%eval( %eval( %secs - %1)/1000\60))");
	//parse_script(tri->script);
	//    int i;
	//    for (i=0;i<=20;i++)

	nstart = GetTickCount();

	nstop = GetTickCount();
	LOG("Took %lu MS to parse all of that.", nstop - nstart);

	free(tri);
	free(cmd_stack);
}

/* Struct: {Tok_name, usage (string), commands (string), flags)
* Generated by write_shit_good(). This is a huge struct, no? */
struct script_table_command stable[] =
{
	{
		TOK_ABORT                   , "abort"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 1   */
	{
		TOK_ABS                     , "abs"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 2   */
	{
		TOK_ACTION                  , "action"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 3   */
	{
		TOK_ADD                     , "add"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 4   */
	{
		TOK_ADDITEM                 , "additem"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 5   */
	{
		TOK_ADDKEY                  , "addkey"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 6   */
	{
		TOK_ALARM                   , "alarm"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 8   */
	{
		TOK_ALIAS                   , "alias"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 9   */
	{
		TOK_ANSI                    , "ansi"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 10  */
	{
		TOK_API                     , "api"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 11  */
	{
		TOK_ARRAY                   , "array"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 12  */
	{
		TOK_ARRGET                  , "arrget"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 13  */
	{
		TOK_ARRHIGH                 , "arrhigh"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 14  */
	{
		TOK_ARRSET                  , "arrset"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 15  */
	{
		TOK_ASCII                   , "ascii"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 16  */
	{
		TOK_AVERAGE                 , "average"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 17  */
	{
		TOK_BEGINS                  , "begins"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 18  */
	{
		TOK_BITAND                  , "bitand"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 19  */
	{
		TOK_BITNOT                  , "bitnot"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 20  */
	{
		TOK_BITOR                   , "bitor"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 21  */
	{
		TOK_BITXOR                  , "bitxor"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 22  */
	{
		TOK_BREAK                   , "break"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 23  */
	{
		TOK_BTNCOL                  , "btncol"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 24  */
	{
		TOK_BTNENABLE               , "btnenable"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 25  */
	{
		TOK_BTNIMAGE                , "btnimage"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 26  */
	{
		TOK_BUTTON                  , "button"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 27  */
	{
		TOK_CASE                    , "case"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 28  */
	{
		TOK_CHAR                    , "char"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 29  */
	{
		TOK_CHARCOMMENT             , "charcomment"           , "[none]", FL_FUNCTION
	}
	,    /*SE: 30  */
	{
		TOK_CHARNOTES               , "charnotes"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 31  */
	{
		TOK_CLASS                   , "class"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 32  */
	{
		TOK_CLEARBACKBUF            , "clearbackbuf"          , "[none]", FL_FUNCTION
	}
	,    /*SE: 34  */
	{
		TOK_CLIP                    , "clip"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 35  */
	{
		TOK_CLOSE                   , "close"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 36  */
	{
		TOK_COLOR                   , "color"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 37  */
	{
		TOK_COLORNAME               , "colorname"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 39  */
	{
		TOK_CONCAT                  , "concat"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 40  */
	{
		TOK_CONDITION               , "condition"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 41  */
	{
		TOK_COPY                    , "copy"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 42  */
	{
		TOK_COUNT                   , "count"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 43  */
	{
		TOK_COUNTLIST               , "countlist"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 44  */
	{
		TOK_CPUINFO                 , "cpuinfo"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 45  */
	{
		TOK_CRTONL                  , "crtonl"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 46  */
	{
		TOK_CW                      , "cw"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 47  */
	{
		TOK_DB                      , "db"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 48  */
	{
		TOK_DBGET                   , "dbget"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 49  */
	{
		TOK_DBLIST                  , "dblist"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 50  */
	{
		TOK_DBMAX                   , "dbmax"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 51  */
	{
		TOK_DBMIN                   , "dbmin"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 52  */
	{
		TOK_DEFINED                 , "defined"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 53  */
	{
		TOK_DELCLASS                , "delclass"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 54  */
	{
		TOK_DELETE                  , "delete"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 55  */
	{
		TOK_DELITEM                 , "delitem"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 56  */
	{
		TOK_DELKEY                  , "delkey"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 57  */
	{
		TOK_DELNITEM                , "delnitem"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 58  */
	{
		TOK_DICE                    , "dice"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 59  */
	{
		TOK_DICEAVG                 , "diceavg"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 60  */
	{
		TOK_DICEDEV                 , "dicedev"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 61  */
	{
		TOK_DICEMAX                 , "dicemax"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 62  */
	{
		TOK_DICEMIN                 , "dicemin"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 63  */
	{
		TOK_DIR                     , "dir"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 64  */
	{
		TOK_DISABLEHTMLLOG          , "disablehtmllog"        , "[none]", FL_FUNCTION
	}
	,    /*SE: 65  */
	{
		TOK_DUPS                    , "dups"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 66  */
	{
		TOK_EDITOR                  , "editor"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 67  */
	{
		TOK_ENABLEDEBUG             , "enabledebug"           , "[none]", FL_FUNCTION
	}
	,    /*SE: 68  */
	{
		TOK_ENABLEHTMLLOG           , "enablehtmllog"         , "[none]", FL_FUNCTION
	}
	,    /*SE: 69  */
	{
		TOK_ENABLEINTERNALALIAS     , "enableinternalalias"   , "[none]", FL_FUNCTION
	}
	,    /*SE: 70  */
	{
		TOK_ENABLEINTERNALMACRO     , "enableinternalmacro"   , "[none]", FL_FUNCTION
	}
	,    /*SE: 71  */
	{
		TOK_ENABLEINTERNALTRIGGER   , "enableinternaltrigger" , "[none]", FL_FUNCTION
	}
	,    /*SE: 72  */
	{
		TOK_ENDS                    , "ends"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 73  */
	{
		TOK_ERASE                   , "erase"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 74  */
	{
		TOK_EVAL                    , "eval"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 75  */
	{
		TOK_EXEC                    , "exec"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 76  */
	{
		TOK_EXPAND                  , "expand"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 77  */
	{
		TOK_EXPANDDB                , "expanddb"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 78  */
	{
		TOK_EXPANDLIST              , "expandlist"            , "[none]", FL_FUNCTION
	}
	,    /*SE: 79  */
	{
		TOK_FILE                    , "file"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 80  */
	{
		TOK_FILESIZE                , "filesize"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 81  */
	{
		TOK_FIND                    , "find"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 82  */
	{
		TOK_FLOAT                   , "float"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 83  */
	{
		TOK_FORALL                  , "forall"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 84  */
	{
		TOK_FORMAT                  , "format"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 85  */
	{
		TOK_FTP                     , "ftp"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 86  */
	{
		TOK_FUNCTION                , "function"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 87  */
	{
		TOK_GAG                     , "gag"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 88  */
	{
		TOK_GAGOFF                  , "gagoff"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 89  */
	{
		TOK_GAGON                   , "gagon"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 90  */
	{
		TOK_GALIAS                  , "galias"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 91  */
	{
		TOK_GAUGE                   , "gauge"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 92  */
	{
		TOK_GETGLOBAL               , "getglobal"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 93  */
	{
		TOK_GETSTATISTICS           , "getstatistics"         , "[none]", FL_FUNCTION
	}
	,    /*SE: 94  */
	{
		TOK_GREP                    , "grep"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 95  */
	{
		TOK_GSL                     , "gsl"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 96  */
	{
		TOK_GVARIABLE               , "gvariable"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 97  */
	{
		TOK_HANDLE                  , "handle"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 98  */
	{
		TOK_HIGHLIGHT               , "highlight"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 99  */
	{
		TOK_IF                      , "if"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 100 */
	{
		TOK_IMAGE                   , "image"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 101 */
	{
		TOK_INSERT                  , "insert"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 102 */
	{
		TOK_INT                     , "int"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 103 */
	{
		TOK_ISFLOAT                 , "isfloat"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 104 */
	{
		TOK_ISKEY                   , "iskey"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 105 */
	{
		TOK_ISMEMBER                , "ismember"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 106 */
	{
		TOK_ISNUMBER                , "isnumber"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 107 */
	{
		TOK_ITEM                    , "item"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 108 */
	{
		TOK_KEY                     , "key"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 109 */
	{
		TOK_KILLALL                 , "killall"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 110 */
	{
		TOK_KILLCLIENT              , "killclient"            , "[none]", FL_FUNCTION
	}
	,    /*SE: 111 */
	{
		TOK_LEFT                    , "left"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 112 */
	{
		TOK_LEFTBACK                , "leftback"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 113 */
	{
		TOK_LEN                     , "len"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 114 */
	{
		TOK_LITERAL                 , "literal"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 115 */
	{
		TOK_LMAP                    , "lmap"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 116 */
	{
		TOK_LOG                     , "log"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 117 */
	{
		TOK_LOOP                    , "loop"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 118 */
	{
		TOK_LOOPDB                  , "loopdb"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 119 */
	{
		TOK_LOWER                   , "lower"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 120 */
	{
		TOK_MATCH                   , "match"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 121 */
	{
		TOK_MATH                    , "math"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 122 */
	{
		TOK_MAX                     , "max"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 123 */
	{
		TOK_MCP                     , "mcp"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 124 */
	{
		TOK_MENU                    , "menu"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 125 */
	{
		TOK_MIN                     , "min"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 126 */
	{
		TOK_MOD                     , "mod"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 127 */
	{
		TOK_MSS                     , "mss"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 128 */
	{
		TOK_MXPTRIG                 , "mxptrig"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 129 */
	{
		TOK_NCONFIG                 , "nconfig"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 130 */
	{
		TOK_NLTOCR                  , "nltocr"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 131 */
	{
		TOK_NORM                    , "norm"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 132 */
	{
		TOK_NULL                    , "null"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 133 */
	{
		TOK_NUMBER                  , "number"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 134 */
	{
		TOK_NUMBUTTONS              , "numbuttons"            , "[none]", FL_FUNCTION
	}
	,    /*SE: 136 */
	{
		TOK_NUMITEMS                , "numitems"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 137 */
	{
		TOK_NUMKEYS                 , "numkeys"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 138 */
	{
		TOK_NUMPARAM                , "numparam"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 139 */
	{
		TOK_NUMREC                  , "numrec"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 140 */
	{
		TOK_NUMWORDS                , "numwords"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 141 */
	{
		TOK_ONINPUT                 , "oninput"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 142 */
	{
		TOK_PARAM                   , "param"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 143 */
	{
		TOK_PATH                    , "path"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 144 */
	{
		TOK_PCOL                    , "pcol"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 145 */
	{
		TOK_PICK                    , "pick"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 146 */
	{
		TOK_POP                     , "pop"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 147 */
	{
		TOK_POS                     , "pos"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 148 */
	{
		TOK_PRIORITY                , "priority"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 149 */
	{
		TOK_PROMPT                  , "prompt"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 150 */
	{
		TOK_PROPER                  , "proper"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 151 */
	{
		TOK_PSUB                    , "psub"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 152 */
	{
		TOK_PUSH                    , "push"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 153 */
	{
		TOK_QUERY                   , "query"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 154 */
	{
		TOK_QUOTE                   , "quote"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 155 */
	{
		TOK_RANDOM                  , "random"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 156 */
	{
		TOK_READ                    , "read"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 158 */
	{
		TOK_RECORD                  , "record"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 159 */
	{
		TOK_REGEX                   , "regex"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 160 */
	{
		TOK_REMOVE                  , "remove"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 162 */
	{
		TOK_RENAME                  , "rename"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 163 */
	{
		TOK_REPEAT                  , "repeat"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 164 */
	{
		TOK_REPLACE                 , "replace"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 166 */
	{
		TOK_REPLACEITEM             , "replaceitem"           , "[none]", FL_FUNCTION
	}
	,    /*SE: 167 */
	{
		TOK_RESET                   , "reset"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 168 */
	{
		TOK_RESUME                  , "resume"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 169 */
	{
		TOK_RIGHT                   , "right"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 170 */
	{
		TOK_RIGHTBACK               , "rightback"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 171 */
	{
		TOK_ROUND                   , "round"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 172 */
	{
		TOK_SEND                    , "send"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 173 */
	{
		TOK_SET                     , "set"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 174 */
	{
		TOK_SETGLOBAL               , "setglobal"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 175 */
	{
		TOK_SETPROMPT               , "setprompt"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 176 */
	{
		TOK_SETSCROLL               , "setscroll"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 177 */
	{
		TOK_SORT                    , "sort"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 178 */
	{
		TOK_SQRT                    , "sqrt"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 179 */
	{
		TOK_STATE                   , "state"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 181 */
	{
		TOK_STATUS                  , "status"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 182 */
	{
		TOK_STDEV                   , "stdev"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 183 */
	{
		TOK_STRING                  , "string"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 184 */
	{
		TOK_STRIPANSI               , "stripansi"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 185 */
	{
		TOK_STRIPQ                  , "stripq"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 186 */
	{
		TOK_STW                     , "stw"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 187 */
	{
		TOK_SUBCHAR                 , "subchar"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 188 */
	{
		TOK_SUBREGEX                , "subregex"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 189 */
	{
		TOK_SUBSTITUTE              , "substitute"            , "[none]", FL_FUNCTION
	}
	,    /*SE: 190 */
	{
		TOK_SUM                     , "sum"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 191 */
	{
		TOK_SUSPEND                 , "suspend"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 192 */
	{
		TOK_TP                      , "tp"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 193 */
	{
		TOK_TM                      , "tm"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 194 */
	{
		TOK_TQ                      , "tq"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 195 */
	{
		TOK_TAB                     , "tab"                   , "[none]", FL_FUNCTION
	}
	,    /*SE: 196 */
	{
		TOK_TEMP                    , "temp"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 197 */
	{
		TOK_TIME                    , "time"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 198 */
	{
		TOK_TIMER                   , "timer"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 199 */
	{
		TOK_TRIGGER                 , "trigger"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 200 */
	{
		TOK_TRIM                    , "trim"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 202 */
	{
		TOK_TRIMLEFT                , "trimleft"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 203 */
	{
		TOK_TRIMRIGHT               , "trimright"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 204 */
	{
		TOK_TS                      , "ts"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 205 */
	{
		TOK_TYPE                    , "type"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 206 */
	{
		TOK_TZ                      , "tz"                    , "[none]", FL_FUNCTION
	}
	,    /*SE: 207 */
	{
		TOK_UNALIAS                 , "unalias"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 208 */
	{
		TOK_UNBUTTON                , "unbutton"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 209 */
	{
		TOK_UNCLASS                 , "unclass"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 210 */
	{
		TOK_UNDIR                   , "undir"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 211 */
	{
		TOK_UNGAG                   , "ungag"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 212 */
	{
		TOK_UNKEY                   , "unkey"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 213 */
	{
		TOK_UNMENU                  , "unmenu"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 214 */
	{
		TOK_UNTAB                   , "untab"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 215 */
	{
		TOK_UNTIL                   , "until"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 216 */
	{
		TOK_UNTRIGGER               , "untrigger"             , "[none]", FL_FUNCTION
	}
	,    /*SE: 217 */
	{
		TOK_UNVAR                   , "unvar"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 218 */
	{
		TOK_UNWATCH                 , "unwatch"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 219 */
	{
		TOK_UPPER                   , "upper"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 220 */
	{
		TOK_VARIABLE                , "variable"              , "[none]", FL_FUNCTION
	}
	,    /*SE: 221 */
	{
		TOK_VIEWREC                 , "viewrec"               , "[none]", FL_FUNCTION
	}
	,    /*SE: 222 */
	{
		TOK_WATCH                   , "watch"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 223 */
	{
		TOK_WHILE                   , "while"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 224 */
	{
		TOK_WINDOW                  , "window"                , "[none]", FL_FUNCTION
	}
	,    /*SE: 225 */
	{
		TOK_WORD                    , "word"                  , "[none]", FL_FUNCTION
	}
	,    /*SE: 226 */
	{
		TOK_WRITE                   , "write"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 228 */
	{
		TOK_YESNO                   , "yesno"                 , "[none]", FL_FUNCTION
	}
	,    /*SE: 229 */
	{
		0, NULL, NULL,0
	}
};

void sort_list(int count, struct script_table_command tab[])
{
	int i, j;
	struct script_table_command temp;

	for (i = 0; i < count - 1; i++)
		for (j = i + 1; j < count; j++)
			if (strcmp(tab[i].name, tab[j].name) > 0)
			{
				temp = tab[i];
				tab[i] = tab[j];
				tab[j] = temp;
			}
}

VR *new_var(void)
{
	static VR vr;
	VR * pvar;

	if (freevar == NULL)
		pvar = malloc(sizeof(*pvar));
	else
	{
		pvar = freevar;
		freevar = freevar->next;
	}

	*pvar = vr;
	pvar->name = &str_emp[0];
	pvar->script = &str_emp[0];
	pvar->cl = NULL;

	return pvar;
}

CL *new_class(void)
{
	static CL cl;
	CL * pclass;

	if (freeclass == NULL)
		pclass = malloc(sizeof(*pclass));
	else
	{
		pclass = freeclass;
		freeclass = freeclass->next;
	}

	*pclass = cl;
	pclass->name = &str_emp[0];
	pclass->enabled = FALSE;
	pclass->priority = 0;

	return pclass;
}

TR *new_trigger(void)
{
	static TR tr;
	TR * ptrigger;

	if (freetrigger == NULL)
		ptrigger = malloc(sizeof(*ptrigger));
	else
	{
		ptrigger = freetrigger;
		freetrigger = freetrigger->next;
	}

	*ptrigger = tr;
	ptrigger->name = &str_emp[0];
	ptrigger->enabled = FALSE;
	ptrigger->priority = 0;
	ptrigger->cl = NULL;
	ptrigger->script = &str_emp[0];

	return ptrigger;
}

AL *new_alias(void)
{
	static AL al;
	AL *palias;

	if (freealias == NULL)
		palias = malloc(sizeof(*palias));
	else
	{
		palias = freealias;
		freealias = freealias->next;
	}

	*palias = al;
	palias->name = &str_emp[0];
	palias->enabled = FALSE;
	palias->priority = 0;
	palias->cl = NULL;
	palias->script = &str_emp[0];

	return palias;
}

MC *new_macro(void)
{
	static MC mc;
	MC *pmacro;

	if (freemacro == NULL)
		pmacro = malloc(sizeof(*pmacro));
	else
	{
		pmacro = freemacro;
		freemacro = freemacro->next;
	}
	*pmacro = mc;
	pmacro->name = &str_emp[0];
	pmacro->enabled = FALSE;
	pmacro->priority = 0;
	pmacro->cl = NULL;
	pmacro->script = &str_emp[0];

	return pmacro;
}

PA *new_path(void)
{
	static PA pa;
	PA *ppath;

	if (freepath == NULL)
		ppath = malloc(sizeof(*ppath));
	else
	{
		ppath = freepath;
		freepath = freepath->next;
	}

	*ppath = pa;
	ppath->name = &str_emp[0];
	ppath->enabled = FALSE;
	ppath->priority = 0;
	ppath->cl = NULL;
	ppath->script = &str_emp[0];

	return ppath;
}

void free_scripts(void)
{
	free_class();
	free_path();
	free_trigger();
	free_alias();
	free_macro();
}

void free_class(void)
{
	CL *cl;
	for (cl = classlist; cl; cl = cl->next)
		free(cl);
	return;
}

void free_path(void)
{
	PA *pa;

	for (pa = pathlist; pa; pa = pa->next)
	{
		if (pa != NULL)
			free(pa);
	}
	return;
}

void free_trigger(void)
{
	TR * tr;
	for (tr = triggerlist; tr; tr = tr->next)
		free(tr);

	return;
}

void free_alias(void)
{
	AL *al;
	for (al = aliaslist; al; al = al->next)
		free(al);
	return;
}

void free_macro(void)
{
	MC *mc;

	for (mc = macrolist; mc; mc = mc->next)
		free(mc);
	return;
}

// This creates a new class
// It also makes the default main_class if no main_class is in existance.
// -Alex
void handle_class(char * input)
{
	CL *newClass;
	char thisName[100];
	char thisPriority[4];

	int pri;

	if (classlist == NULL)
	{
		// this should only run once!
		classlist = new_class();
		classlist->enabled = TRUE;
		classlist->name = str_dup("main_class");
		classlist->priority = 0;
		classlist->next = NULL;
	}

	newClass = new_class();

	if (newClass == NULL)
		GiveError("Null class encountered... that's not good m'kay?", TRUE);

	input = script_strip(input, thisName);
	input = script_strip(input, thisPriority);

	if (thisName[0] == '\0')
	{
		// this means it's a default class!
		newClass = classlist;
		return;
	}

	else
	{
		if (atoi(thisPriority) > 1000)
			pri = 1000;
		else if (atoi(thisPriority) < 0)
			pri = 0;
		else
			pri = atoi(thisPriority);

		newClass->name = str_dup(thisName);
		newClass->enabled = TRUE;
		newClass->priority = pri;
		newClass->next = classlist->next;
		classlist->next = newClass;
	}

	return;
}

// This creates a new trigger with the proper input! NOTE needs to be updated when we imp a global
// class. -Alex
void handle_triggers(char * input)
{
	TR *trigger;
	CL *cls2;
	int pri;

	char thisName[1000];
	char thisScript[10000];
	char thisPriority[4];
	char cls[100];

	trigger = new_trigger();

	if (trigger == NULL)
		GiveError("Trigger reported NULL!", TRUE);

	input = script_strip(input, thisName);
	input = script_strip(input, thisScript);
	input = script_strip(input, thisPriority);
	input = script_strip(input, cls);

	if (thisName[0] == '\0')
	{
		GiveError("Improper Trigger format of type: Name", FALSE);
		return;
	}
	if (atoi(thisPriority) > 1000)
		pri = 1000;
	else if (atoi(thisPriority) < 0)
		pri = 0;
	else
		pri = atoi(thisPriority);

	for (cls2 = classlist; cls2 != NULL; cls2++)
	{
		if (string_compare(cls, cls2->name))
			break;
	}

	trigger->name = str_dup(thisName);
	trigger->script = str_dup(thisScript);
	trigger->enabled = TRUE;
	trigger->priority = pri;
	trigger->next = triggerlist;
	// NOTE we should add a GLOBAL class that is the default WHEN we do, this NEEDS to be updated. -
	// Alex done and done, classlist points to the uberclass item only problem is if it never ran
	// the handle_class function.... crap mike, you wanna some up with a better solution? well I
	// guess it will still work, since the classlist pointer is changed in that code, but until it
	// does run a handle_class funtion, this will point to NULL, or worse -Alex
	trigger->cl = (cls2 == NULL ? classlist : cls2);
	triggerlist = trigger;

	return;
}

void handle_aliases(char * input)
{
	AL *alias;

	char name[200];
	char value[200];
	char priority[40];
	char cls[100];
	CL *cls2;
	int pri;

	alias = new_alias();
	if (alias == NULL)
		GiveError("Alias Failed to initialize", TRUE);

	input = script_strip(input, name);
	input = script_strip(input, value);
	input = script_strip(input, priority);
	input = script_strip(input, cls);

	if (name[0] == '\0')
	{
		GiveError("Improper Alias format of type: name", FALSE);
		return;
	}
	if (value[0] == '\0')
	{
		GiveError("Improper Alias format of type: value", FALSE);
		return;
	}

	if (atoi(priority) > 1000)
		pri = 1000;
	else if (atoi(priority) < 0)
		pri = 0;
	else
		pri = atoi(priority);

	for (cls2 = classlist; cls2 != NULL; cls2++)
	{
		if (string_compare(cls, cls2->name))
			break;
	}

	alias->name = str_dup(name);
	alias->enabled = TRUE;
	alias->priority = pri;
	alias->script = str_dup(value);
	alias->next = aliaslist;
	alias->cl = (cls2 == NULL ? classlist : cls2);
	aliaslist = alias;

	return;
}
void handle_macros(char * input)
{
	return;
}
void handle_var(char *input)
{
	VR *pvar;
	char name[200];
	char value[2048];

	pvar = new_var();
	if (pvar == NULL)
		GiveError("Variable failed to initialize.", TRUE);

	input = script_strip(input, name);
	input = script_strip(input, value);

	pvar->next = varlist;
	pvar->name = str_dup(name);
	pvar->script = str_dup(value);

	varlist = pvar;
}

void handle_path(char * input)
{
	PA *path;
	char name[200];
	char whereto[2048];
	char priority[4];
	char cls[100];

	CL *cls2;
	int pri;

	path = new_path();
	if (path == NULL)
		GiveError("Path failed to initialize", TRUE);

	input = script_strip(input, name);
	input = script_strip(input, whereto);
	input = script_strip(input, priority);
	input = script_strip(input, cls);

	if (name[0] == '\0')
	{
		GiveError("Improper Path format of type: name", FALSE);
		return;
	}

	if (atoi(priority) > 1000)
		pri = 1000;
	else if (atoi(priority) < 0)
		pri = 0;
	else
		pri = atoi(priority);

	for (cls2 = classlist; cls2 != NULL; cls2++)
	{
		if (string_compare(cls, cls2->name))
			break;
	}

	path->name = str_dup(name);
	path->enabled = TRUE;
	path->priority = pri;
	path->script = str_dup(whereto);
	path->next = pathlist;
	path->cl = (cls2 == NULL ? classlist : cls2);
	pathlist = path;
	return;
}
void handle_url(char * input)
{
	return;
}
void handle_open(char * input)
{
	return;
}
void handle_log(char * input)
{
	return;
}
void handle_help(char * input)
{
	return;
}
void handle_capture(char * input)
{
	return;
}
void handle_script(char * input)
{
	return;
}
void handle_option(char * input)
{
	return;
}
void handle_save(char * input)
{
	return;
}

void handle_scripts(char *input, char *output)
{
	return;
}

BOOL check_alias(char * input)
{
	AL *alias;
	char command[32000];

	input = one_argument(input, command);
	alias = aliaslist;
	if (alias == NULL)
		return FALSE;
	for (alias = aliaslist; alias != NULL; alias = alias->next)
	{
		if (!strcmp(command, alias->name))
		{
			// MessageBox(MudMain, alias->script,"",MB_OK);
			//handle_input (alias->script);
			//give_term_debug("Doing alias: %s", alias->script);
			//update_term();
			return TRUE;
		}
	}

	return FALSE;
}

// This scans the input string for a trigger name, then runs the trigger
// if it matches the input!
void check_trigger(char *input)
{
	TR *trigger;
	char *point;

	trigger = triggerlist;

	if (trigger == NULL)
		return;
	for (; trigger != NULL; trigger = trigger->next)
	{
		point = strstr(input, trigger->name);
		if (point != NULL)
		{
			//parse_trigger(trigger);
			// parse will do all the real work!
		}
	}

	return;
}

BOOL check_path(char *input)
{
	PA *path;
	char command[500];
	input = one_argument(input, command);

	path = pathlist;
	if (path == NULL)
		return FALSE;
	for (path = pathlist; path != NULL; path = path->next)
	{
		if (!strcmp(command, path->name))
		{
			return TRUE;
			continue;
		}
	}

	return FALSE;
}
void check_macro(char *input)
{
	return;
}

void handle_set_options(char *input)
{
	input[strlen(input)] = '\0';
	if (!strprefix("name", input))
	{
		this_session->name = str_dup(&input[5]);
		give_term_debug("Name set to %s.", &input[5]);
	}
	else if (!strprefix("host", input))
	{
		this_session->host = str_dup(&input[5]);
		give_term_debug("Host set to %s.", &input[5]);
		update_term();
	}
	else if (!strprefix("port", input))
	{
		this_session->port = atoi(&input[5]);
		give_term_debug("Port set to %s.", &input[5]);
		update_term();
	}
	else if (!strprefix("color", input))
	{
		if (input[strlen("color") + 1] == '1')
			this_session->color = TRUE;
		else
			this_session->color = FALSE;
	}
	//else if (!strprefix("max_buffer", input))
		//this_session->max_buffer = atoi(&input[11]);
	else if (!strprefix("UseMemoryCompression", input))
	{
		if (input[strlen("UseMemoryCompression") + 1] == '1')
			this_session->UseMemoryCompression = TRUE;
		else
			this_session->UseMemoryCompression = FALSE;
	}
	else if (!strprefix("IsBetaTester", input))
	{
		if (input[strlen("IsBetaTester") + 1] == '1')
			this_session->IsBetaTester = TRUE;
		else
			this_session->IsBetaTester = FALSE;
	}
	else if (!strprefix("BetaEdit", input))
	{
		if (input[strlen("BetaEdit") + 1] == '1')
			this_session->beta_edit = TRUE;
		else
			this_session->beta_edit = FALSE;
	}

	else if (!strprefix("EnableTestLogging", input))
	{
		if (input[strlen("EnableTestLogging") + 1] == '1')
			this_session->EnableTestLogging = TRUE;
		else
			this_session->EnableTestLogging = FALSE;
	}
	else if (!strprefix("OptimizeDualScreen", input))
	{
		if (input[strlen("OptimizeDualScreen") + 1] == '1')
			this_session->OptimizeDualScreen = TRUE;
		else
			this_session->OptimizeDualScreen = FALSE;
	}
	else if (!strprefix("EnableScripts", input))
	{
		if (input[strlen("EnableScripts") + 1] == '1')
			this_session->EnableScripts = TRUE;
		else
			this_session->EnableScripts = FALSE;
	}
	else if (!strprefix("EnableAliases", input))
	{
		if (input[strlen("EnableAliases") + 1] == '1')
			this_session->EnableAliases = TRUE;
		else
			this_session->EnableAliases = FALSE;
	}
	else if (!strprefix("EnableTriggers", input))
	{
		if (input[strlen("EnableTriggers") + 1] == '1')
			this_session->EnableTriggers = TRUE;
		else
			this_session->EnableTriggers = FALSE;
	}
	else if (!strprefix("EnablePaths", input))
	{
		if (input[strlen("EnablePaths") + 1] == '1')
			this_session->EnablePaths = TRUE;
		else
			this_session->EnablePaths = FALSE;
	}
	else if (!strprefix("EnableMacros", input))
	{
		if (input[strlen("EnableMacros") + 1] == '1')
			this_session->EnableMacros = TRUE;
		else
			this_session->EnableMacros = FALSE;
	}
	else if (!strprefix("EnableSplashScreen", input))
	{
		if (input[strlen("EnableSplashScreen") + 1] == '1')
			this_session->EnableSplashScreen = TRUE;
		else
			this_session->EnableSplashScreen = FALSE;
	}
	else if (!strprefix("EnableClientChat", input))
	{
		if (input[strlen("EnableClientChat") + 1] == '1')
			this_session->EnableClientChat = TRUE;
		else
			this_session->EnableClientChat = FALSE;
	}
	else if (!strprefix("EnablePing", input))
	{
		if (input[strlen("EnablePing") + 1] == '1')
			this_session->EnablePing = TRUE;
		else
			this_session->EnablePing = FALSE;
	}
	else if (!strprefix("EnableUsageReports", input))
	{
		if (input[strlen("EnableUsageReports") + 1] == '1')
			this_session->EnableUsageReports = TRUE;
		else
			this_session->EnableUsageReports = FALSE;
	}
	else if (!strprefix("EnableBlinkies", input))
	{
		if (input[strlen("EnableBlinkies") + 1] == '1')
			this_session->EnableBlinkies = TRUE;
		else
			this_session->EnableBlinkies = FALSE;
	}
	else if (!strprefix("EnableSound", input))
	{
		if (input[strlen("EnableSound") + 1] == '1')
			this_session->EnableSound = TRUE;
		else
			this_session->EnableSound = FALSE;
	}
	else if (!strprefix("EnableTN", input))
	{
		if (input[strlen("EnableTN") + 1] == '1')
			this_session->EnableTN = TRUE;
		else
			this_session->EnableTN = FALSE;
	}
	else if (!strprefix("ShowTimeStamps", input))
	{
		if (input[strlen("ShowTimeStamps") + 1] == '1')
			this_session->ShowTimeStamps = TRUE;
		else
			this_session->ShowTimeStamps = FALSE;
	}
	else if (!strprefix("ShowDebug", input))
	{
		if (input[strlen("ShowDebug") + 1] == '1')
			this_session->show_debug = TRUE;
		else
			this_session->show_debug = FALSE;
	}
	else if (!strprefix("ShowMouseCoords", input))
	{
		if (input[strlen("ShowMouseCoords") + 1] == '1')
			this_session->Mouse_coords = TRUE;
		else
			this_session->Mouse_coords = FALSE;
	}
	else
		give_term_error("Unrecognized option. Please try again.");
}

/* No actual parsing is done here, only checking the func_type table for
* commands and whatnot
*/

void handle_input(char * in)
{
	unsigned long int runner = 0;
	typedef struct termbuf      SBuf;
	char *command;
	extern char SMILE_FACE[];
	extern char Greet[];

	char buff2[10000];
	char buffer[10000];
	char buff3[10000];
	char buff4[10000];
	//	extern SBuf *send_buff[100];
	AL *alias;
	PA *path;
	char *point = buffer;
	char *pbuf;
	int list;

	unsigned long int ilen = strlen(in);

	command = malloc(sizeof(char) * ilen + 10);

	if (ilen < 10)
		ilen = 10;
	command[0] = '\0';
	buff2[0] = '\0';
	buff3[0] = '\0';
	buff4[0] = '\0';
	buffer[0] = '\0';
	list = 0;

	strcpy(buffer, in);

	in = one_argument(in, command);

	update_term();

	pbuf = buff3;
	if (!buffer)
	{
		GiveError(in, 0);
		return;
	}
	if (strprefix("#", &command[0]))
	{
		if ((strchr(buffer, ';') != NULL) && (strlen(strstr(buffer, ";")) != strlen(buffer)))
		{
			for (; *point; point++)
			{
				if (*point == '\0')
					break;

				if (*point == ';')
				{
					buff3[0] = '\0';
					handle_input(buff4);
					buff4[0] = '\0';
					continue;
				}
				*pbuf = *point;
				pbuf[1] = '\0';
				strcat(buff4, pbuf);
			}
			if (buff4[0] != '\0')
			{
				buff3[0] = '\0';
				handle_input(buff4);
				buff4[0] = '\0';

				free(command);

				return;
			}
			free(command);

			return;
		}
		else if (buffer[0] == ';' && (strstr(&buffer[1], ";") != NULL))
		{
			// Let's send the first command on off to the thingie
			for (runner = 0; *point; point++, runner++)
			{
				if (*point == ';' && runner != 0)
					break;

				*pbuf = *point;
				pbuf[1] = '\0';
				strcat(buff4, pbuf);
			}

			strcat(buff2, buff4);
			strcat(buff2, "\n");
			for (runner = 0; runner <= 100 || send_buff[runner] != NULL; runner++)
			{
				if (send_buff[runner]->buffer == NULL)
				{
					send_buff[runner]->buffer = str_dup(buff2);

					check_output();
					break;
				}
			}
			buff2[0] = '\0';
			if (!TERM_ECHO_OFF)
			{
				strcat(buff2, ANSI_YELLOW);
				strcat(buff2, buff4);
				strcat(buff2, "\033[0m");
				strcat(buff2, "\n");
				ParseLines(str_dup(buff2));
			}
			tbuf->y_end += 13;
			tbuf->x_end = 0;
			pbuf[0] = '\0';
			buff4[0] = '\0';
			buff2[0] = '\0';
			buff3[0] = '\0';
			*point++;

			for (; *point; *point++)
			{
				*pbuf = *point;
				strcat(buff4, pbuf);
			}
			handle_input(buff4);
			free(command);

			return;
		}

		if (check_alias(command) == TRUE)
		{
			for (alias = aliaslist; alias != NULL; alias = alias->next)
			{
				if (!strcmp(command, alias->name))
				{
					strcat(buff3, alias->script);
					strcat(buff3, " ");
					if (in[0] != '\0')
						strcat(buff3, in);

					memcpy(buffer, buff3, strlen(buff3));

					handle_input(buff3);
					free(command);
					buff3[0] = '\0';
					buffer[0] = '\0';

					return;
				}
			}
		}

		if (!strprefix(".", &command[0]))
		{
			if (check_path(&command[1]) == TRUE)
			{
				for (path = pathlist; path != NULL; path = path->next)
				{
					if (!strcmp(&command[1], path->name))
					{
						buff3[0] = '\0';
						buffer[0] = '\0';
						//                          strcat(buff3, path->script);
						//                          strcat(buff3, " ");
						//                          strcat(buff3, in);
						memcpy(buffer, buff3, strlen(buff3));//sizeof(buff3));

						give_term_debug(path->script);
						nasty = TRUE;
						handle_input(path->script);
						nasty = FALSE;
						update_term();
						free(command);
						return;
					}
				}
			}
			give_term_error("Unknown path [%s]", &command[1]);
			update_term();
			return;
		}

		if (!TERM_ECHO_OFF && buffer[0] != '\0')
		{
			strcat(buff2, ANSI_YELLOW);
			strcat(buff2, buffer);
			strcat(buff2, "\033[0m ");

			strcat(buff2, "\n");
			strcat(buff2, "\0");

			ParseLines(str_dup(buff2));
		}

		if (strlen(buff2) == 0)
			strcat(buff2, "\n");

		strcat(buffer, "\n");
		//give_term_error("%sSending \"%s\" to mud \033[0m", ANSI_C_1BLINK, buffer);
		for (runner = 0; runner <= 100 || send_buff[runner] != NULL; runner++)
		{
			if (!send_buff[runner])
				break;
			if (send_buff[runner]->buffer == '\0')
			{
				send_buff[runner]->buffer = str_dup(buffer);
				check_output();
				break;
			}
		}
		tbuf->y_end += 13;
		tbuf->x_end = 0;
		buffer[0] = '\0';
		free(command);
		return;
	}

	if (!strprefix(command, "#trigger"))
		handle_triggers(in);
	else if (!strprefix(command, "#alias"))
	{
		handle_aliases(in);
		return;
	}

	else if (!strprefix(command, "#importansi"))
	{
		import_file(in);
		return;
	}
	else if (!strprefix(command, "#beep"))
	{
		terminal_beep();
		return;
	}
	else if (!strprefix(command, "#macro"))
		handle_macros(in);
	else if (!strprefix(command, "#path"))
		handle_path(in);
	else if (!strprefix(command, "#url"))
		handle_url(in);
	else if (!strprefix(command, "#class"))
		handle_class(in);
	else if (!strprefix(command, "#open"))
		handle_open(in);
	else if (!strprefix(command, "#log"))
		handle_log(in);
	else if (!strprefix(command, "#dumplog"))
		dump_echo();
	else if (!strprefix(command, "#clearlogs"))
		clear_log();
	else if (!strprefix(command, "#capture"))
		handle_capture(in);
	else if (!strprefix(command, "#option"))
		handle_option(in);
	else if (!strprefix(command, "#save"))
		handle_save(in);
	else if (!strprefix(command, "#var"))
		handle_var(in);
	else if (!strprefix(command, "#showcommandhistory")) // Show the command history.
	{
		int h = 0;
		int cmdcnt = 0;
		give_term_info("Command history is as follow:");
		for (h = 0; h < MAX_INPUT_HISTORY; h++)
		{
			if (cmdhistory[h].command[0] == '\0')
				continue; // Don't show it.
			give_term_info("%d) %s", h + 1/* So 0 index doesn't confuse people */, cmdhistory[h].command);
			cmdcnt++;
		}
		give_term_info("Total commands in history: %d", cmdcnt);
		update_term();
	}
	else if (!strprefix(command, "#easter1"))
		ParseLines(str_dup(Greet));
	else if (!strprefix(command, "#easter2"))
		ParseLines(str_dup(SMILE_FACE));
	else if (!strprefix(command, "#setoption"))
	{
		handle_set_options(in);
	}
	else if (!strprefix(command, "#time"))
		do_timed(in);
	else if (!strprefix(command, "#termclear"))
	{
		FreeTerm();

		update_term();
	}
	else if (!strprefix(command, "#quit"))
	{
		char buf[100];
		int runner = 0;
		dump_heap();
		fflush(0);
		if (IS_IN_DEBUGGING_MODE == 1)
			sprintf(buf, "Thank you for using NanoMud v.%s.", Mud_client_Version);
		else
			sprintf(buf, "Thank you for using NanoMud v.%s.", Mud_client_Version);

		GiveError(buf, FALSE);

		save_scripts();

		save_settings();

		FreeTerm();
		return_usage();
#ifndef NANOMUD_NANO
		destroy_editors();
#endif

		for (runner = 0; runner <= 100; runner++)
		{
			free(send_buff[runner]);
		}
		free(this_session->termlist);
		free(this_session);
		free(tbuf);
		//free_scripts();

		save_scripts();

		walk_heap();
		PostQuitMessage(0);
		return;
	}
	else if (!strprefix(command, "#updateterminal"))
	{
		give_term_info("Terminal screen updated.");
		update_term();
	}

	else if (!strprefix(command, "#repeat"))
		do_repeat(in, NULL, NULL, NULL);
	else if (!strprefix(command, "#import"))
		do_import(in, NULL, NULL, NULL);
	else if (!strprefix(command, "#echoon"))
	{
		give_term_debug("Echo On!");
		update_term();
		TERM_ECHO_OFF = FALSE;
	}
	else if (!strprefix(command, "#echooff"))
	{
		give_term_debug("Echo off!");
		update_term();
		TERM_ECHO_OFF = TRUE;
	}
	else if (!strprefix(command, "#listalias"))
	{
		list = 0;
		give_term_echo("Current aliases: ");
		for (alias = aliaslist; alias != NULL; alias = alias->next)
		{
			list++;
			give_term_echo("[%d] Alias name [%s] Alias script [%s] Priority [%d]", list, alias->name, alias->script, alias->priority);
		}
		if (list = 0)
		{
			give_term_echo("No current aliases defined.");
		}
		update_term();
	}

	else if (!strprefix(command, "#listpath"))
	{
		list = 0;
		give_term_echo("Current pathes: ");
		for (path = pathlist; path != NULL; path = path->next)
		{
			list++;
			give_term_echo("[%d] path name [%s] path script [%s] Priority [%d]", list, path->name, path->script, path->priority);
		}
		if (list = 0)
		{
			give_term_echo("No current pathes defined.");
		}
		update_term();
	}

	SendMessage(MudInput, WM_SETTEXT, 0, (LPARAM)(LPCSTR)"");
	free(command);
	return;
}

void check_string(char *pattern, char *str)
{
	//   LOG("Analyzing string: %s with pattern of: %s", str, pattern);
	//    if (fnmatch(pattern, str, 0) == 0)
	//      GiveError("Match", FALSE);
}

BOOL is_operator(char *point)
{
	if (!point)
		return FALSE;
	if (point[0] == '{' || point[0] == '}'
		|| point[0] == '+' || point[0] == '-'
		|| point[0] == '=' || point[0] == '*'
		|| point[0] == '/' || point[0] == '#'
		|| point[0] == '%' || point[0] == '@'
		|| point[0] == '(' || point[0] == ')'
		|| point[0] == '\\' || point[0] == '|'
		|| point[0] == '^' || point[0] == '$'
		|| point[0] == '!' || point[0] == '<'
		|| point[0] == '>' || point[0] == '?'
		|| point[0] == ':' || point[0] == '\''
		|| point[0] == ';' || point[0] == ','
		|| point[0] == '~' || point[0] == '`'
		|| point[0] == '\"' || point[0] == '['
		|| point[0] == ']')
	{
		return TRUE;
	}
	return FALSE;
}

int is_function(char *str) //This should be a string chunk from space to space. Will check for partial names
{
	int i = 0;

	for (i = 0; stable[i].name != NULL; i++)
		if (!strcmp(makeupper(stable[i].name), makeupper(str)))
			return stable[i].token;

	return -1;
}

unsigned long int tokenize(char * str)
{
	return 0;
}

void make_token(char *str)
{
}

void  strip_space(char*str)
{
	char *point = str;
	char *to_ret;
	char *buffer;
	char buf[2];

	BOOL in_quote = FALSE;
	buffer = buf;
	to_ret = malloc(sizeof(char) * strlen(str));

	to_ret[0] = '\0';

	if (!str)
		return;

	for (; *point; point++)
	{
		if (*point == '"')
		{
			if (in_quote == TRUE)
				in_quote = FALSE;
			else
				in_quote = TRUE;
		}
		if (*point == ' ' && in_quote == FALSE)
			continue;
		*buffer = *point;
		buffer[1] = '\0';
		strcat(to_ret, buffer);
	}
	memcpy(str, to_ret, strlen(to_ret));
	str[strlen(to_ret)] = '\0';
	free(to_ret);
}

void strip_paren(char*str)
{
	char *point = str;
	char *to_ret;
	char *buffer;
	char buf[2];
	buffer = buf;

	if (!str)
		return;

	to_ret = malloc(sizeof(char) * strlen(str));
	to_ret[0] = '\0';
	for (; *point; point++)
	{
		if (*point == ')' || *point == '(')
			continue;
		*buffer = *point;
		buffer[1] = '\0';
		strcat(to_ret, buffer);
	}

	memcpy(str, to_ret, strlen(to_ret));
	str[strlen(to_ret)] = '\0';
	free(to_ret);
}

BOOL is_math(char*str)
{
	char *point = str;
	BOOL found_op = FALSE;

	strip_space(str);
	strip_paren(str);

	for (; *point; point++)
	{
		if (*point == '+' || *point == '-' || *point == '/' || *point == '*'
			|| *point == '%')
		{
			found_op = TRUE;
			continue;
		}
		if (*point >= '0' && *point <= '9')
			continue;
	}

	if (found_op == TRUE)
		return TRUE;
	else
		return FALSE;
}

void do_math_internal(char *str)
{
	long int total;
	char arg1[10000] = "";
	char arg2[10000] = "";
	char *buffer;
	char buf[10000] = "";
	char temp[10000] = "";
	char temp2[10000] = "";
	int oper;
	char *point;
	int count = 0;

	enum
	{
		MUL, DIV, ADD, SUB, MODULO
	};

	point = str;
	buffer = buf;
	arg1[0] = arg2[0] = buf[0] = '\0';
	strip_space(str);
	strip_paren(str);

	if (!is_math(str))
		GiveError("Wow............", 1);

	arg1[0] = '\0';
	arg2[0] = '\0';

	for (; *point; point++, count++)
	{
		if ((*point == '+' || *point == '-' || *point == '/' || *point == '*'
			|| *point == '%') && arg1[0] != '\0')
			break;
		*buffer = *point;
		buffer[1] = '\0';
		strcat(arg1, buffer);
	}
	switch (*point)
	{
	case '+':
		oper = ADD;
		break;
	case '-':
		oper = SUB;
		break;
	case '/':
		oper = DIV;
		break;
	case '*':
		oper = MUL;
		break;
	case '%':
		oper = MODULO;
		break;
	default:
		return;
	}

	*++point;
	count++;

	for (; *point; point++, count++)
	{
		if ((*point == '+' || *point == '-' || *point == '/' || *point == '*'
			|| *point == '%') && arg2[0] != '\0')
			break;
		*buffer = *point;
		buffer[1] = '\0';
		strcat(arg2, buffer);
	}

	memcpy(temp, &str[count], strlen(str) - count);

	switch (oper)
	{
	case ADD:
		if ((!isdigit(arg1[0]) || !isdigit(arg2[0])))
		{
			if ((arg1[0] != '-' && arg2[0] != '-'))
			{
				sprintf(str, "%s%s", arg1, arg2);
				return;
			}
		}

		total = atol(arg1) + atol(arg2);

		break;
	case MUL:
		total = atol(arg1) * atol(arg2);

		break;
	case SUB:
		total = atol(arg1) - atol(arg2);

		break;
	case DIV:
		if (atoi(arg1) == 0 || atoi(arg2) == 0)
		{
			give_term_error("division by 0 error.");
			sprintf(str, "0");
			return;
		}
		total = atol(arg1) / atol(arg2);

		break;
	case MODULO:
		total = atol(arg1) % atol(arg2);

		break;
	default:
		break;
	}
	sprintf(temp2, "%ld%s", total, temp);
	if (is_math(temp2))
		do_math_internal(temp2);
	str[0] = '\0';

	sprintf(str, "%s", temp2);
}

BOOL eval_expression(char * exp)
{
	int idx, ldx, fdx;
	BOOL quote = FALSE;
	char *buffer;
	char buf[11024];
	char stack[11024];

	char *new_string;

	int x;

	char function[11000];
	char *ret;
	static int c = 0;

	int len = strlen(exp);

	char *point = exp;

	fdx = 0;

	new_string = malloc(sizeof(char) * (strlen(exp) * 2));

	stack[0] = '\0';
	idx = 0;
	new_string[0] = '\0';
	buffer = buf;
	idx = ldx = 0;
	for (; *point; point++)
	{
		if (*point == '(')
			fdx++;
		if (*point == ')')
			fdx--;
	}

	while (idx < len)
	{
		if (!quote && exp[idx + 1] == ')')
		{
			ldx = left_token(exp, idx, "(");
			if (idx == 0)
			{
				LOG("Missing open paren");
				free(new_string);
				return 0;
			}

			get_mid(exp, stack, ldx, idx);
			if (is_math(stack))
			{
				do_math_internal(stack);

				memcpy(new_string, exp, ldx);
				new_string[ldx - 1] = '\0';
				x = strlen(new_string);

				memcpy(&new_string[x], stack, strlen(stack));

				memcpy(&new_string[x + strlen(stack)], &exp[idx] + 2, strlen(exp) - (idx)+2);
				memcpy(exp, new_string, strlen(new_string));
				exp[strlen(new_string)] = '\0';
				len = strlen(exp);
			}
			ldx = left_token(exp, ldx - 2, "(");
			memset(function, 0, 1000);
			get_mid(exp, function, ldx, right_token(exp, ldx, "("));

			if (is_function_internal(function))
			{
				ret = interp_function(function, stack, 0, 0, 0);

				memcpy(new_string, exp, ldx);
				new_string[ldx] = '\0';
				x = strlen(new_string);

				memcpy(&new_string[x], ret, strlen(ret) + 1);

				memcpy(&new_string[x + strlen(ret)], &exp[idx + 2], strlen(exp) - (idx));
				memcpy(exp, new_string, strlen(new_string) + 1);

				c++;

				len = strlen(exp);
				LOG(ret);
			}
		}

		idx++;
	}
	if (is_math(exp))
	{
		do_math_internal(exp);
	}
	free(new_string);
	return FALSE;
}

void check_grammar(unsigned long int * token)
{
	int paren = 0; //Parenthesis number.
	int brack = 0; //Bracket ( {} ) number.

	unsigned long int runner = 0; //iterater.
	unsigned long int tok;

	for (runner = 0; token[runner] != TOK_END; runner++)
	{
		tok = token[runner];

		switch (tok)
		{
		case TOK_OPENP:
			paren++;
			continue;
			break;
		case TOK_CLOSEP:
			paren--;
			continue;
			break;
		case TOK_STRING:
		case TOK_CONST:
			continue;
			break;
		case TOK_OPENB:
			brack++;
			continue;
			break;
		case TOK_CLOSEB:
			brack--;
			continue;
			break;
		case TOK_OPER:
			continue;
			break;
		}
	}
	if (paren > 0)
	{
		LOG("Unmatching parenthesis.");
	}
	if (paren < 0)
	{
		LOG("Unmatching parenthesis: Too many closing parenthesis.");
	}
	if (brack < 0)
	{
		LOG("Unmatching brackets: Too many closing brackets.");
	}
	if (brack > 0)
	{
		LOG("Unmatching brackets: Too many opening brackets.");
	}
	return;
}

/* Compile script: This turns a script into a list of tokens/opcodes.
* It will then send it to another function and make sure it's grammar
* is correct. Note: This will only send it for grammar check ONCE. And
* won't send again unless there is a change.
*/

void compile_script(char * scr)
{
	unsigned long int token[10000]; // README: Free this damn thing when we're done.
	unsigned long int i; // Interator.
	char *point;

	char *exp;
	char buf[2555] = "";
	char buf2[2555] = "";
	char *buffer;
	char exp_buf[21024]; //expression buffer -- used to validate expressions
	BOOL endl = FALSE; // used to various boolean stuff within parse.
	int paren;

	buffer = buf2;

	if (scr == NULL || scr[0] == '\0')
		return;

	//    token = (unsigned long int*)malloc(strlen(scr)*3000); // give it lots of space.
	memset(token, 0, sizeof(token));
	point = scr;
	exp = scr;

	i = 0;

	for (;; point++, exp++)
	{
		if (!*point)
		{
			token[i] = TOK_END;
			i++;
			break;
		}

		if (*point == ' ')
			continue;
		if ((*point >= 'a' && *point <= 'z') || (*point >= 'A' && *point <= 'Z')) //a-zA-Z
		{
			buf[0] = '\0';
			for (; *point; point++)
			{
				*buffer = *point;
				if (is_operator(buffer) || *point == ' ')
				{
					*--point;
					break;
				}

				buffer[1] = '\0';
				strcat(buf, buffer);
			}

			if (is_function_internal(buf))
			{
				token[i] = TOK_FUNCTION;
				if (!strcmp(makeupper(buf), "IF"))
				{
					exp += strlen(buf);

					paren = 0;
					exp_buf[0] = '\0';

					for (; *exp; exp++)
					{
						if (*exp == '(')
							paren++;

						if (*exp == ')')
							paren--;

						*buffer = *exp;
						buffer[1] = '\0';
						strcat(exp_buf, buffer);

						if (paren == 0)
						{
							give_term_error("IF: %s", exp_buf);
							exp_buf[0] = ' ';
							exp_buf[strlen(exp_buf) - 1] = ' ';
							strip_space(exp_buf);
							eval_expression(exp_buf);
							if (atol(exp_buf) > 0)
								give_term_debug("If Succeeded.");
							else
								give_term_debug("If Failed.");
							free(token);
							point = exp;
							buf[0] = '\0';
							break;
						}
					}

					LOG("Paren: %d", paren);
				}
				else
				{
					exp += strlen(buf);

					paren = 0;
					exp_buf[0] = '\0';
					for (; *exp; exp++)
					{
						if (*exp == '(')
							paren++;

						if (*exp == ')')
							paren--;

						*buffer = *exp;
						buffer[1] = '\0';
						strcat(exp_buf, buffer);

						if (paren == 0)
						{
							//exp_buf[strlen(exp_buf)-1] = '\0';
							eval_expression(exp_buf);
							if (exp_buf[0] == '"')
								exp_buf[0] = ' ';
							if (exp_buf[strlen(exp_buf) - 1] == '"')
								exp_buf[strlen(exp_buf) - 1] = ' ';

							interp_function(buf, exp_buf, NULL, NULL, NULL);
							free(token);
							point = exp;
							buf[0] = '\0';
							break;
						}
					}
				}

				i++;
				buf[0] = '\0';
			}
			else
			{
				token[i] = TOK_UNKNOWN;
				i++;
				buf[0] = '\0';
			}
			continue;
		}
		if (*point >= '0' && *point <= '9')
		{
			token[i] = TOK_CONST;
			i++;

			for (; *point >= '0' && *point <= '9'; point++)
				;
			*--point;
			continue;
		}
		if (*point == '\"')
		{
			*point++;

			for (; *point; point++)
			{
				endl = TRUE;
				if (*point == '\"')
				{
					token[i] = TOK_STRING;
					i++;
					endl = FALSE;
					break;
				}
			}
			if (endl == TRUE)
			{
				token[i] = TOK_ERROR;
				i++;
				token[i] = TOK_END;
				i++;
				endl = FALSE;
			}
			continue;
		}

		if (*point == '(')
		{
			token[i] = TOK_OPENP;
			i++;
			continue;
		}
		if (*point == ')')
		{
			token[i] = TOK_CLOSEP;
			i++;
			continue;
		}
		if (*point == '}')
		{
			token[i] = TOK_CLOSEB;
			i++;
			continue;
		}
		if (*point == '{')
		{
			token[i] = TOK_OPENB;
			i++;
			continue;
		}
		*buffer = *point;
		buffer[1] = '\0';
		buf[0] = '\0';
		strcat(buf, buffer);
		if (is_operator(buf))
		{
			token[i] = TOK_OPER;
			i++;
			continue;
		}
	}
	i = 0;
	/*  LOG("%s\n\n", scr);
	for (;;)
	{
	if (token[i] == TOK_END)
	{
	LOG("Token END");
	break;
	}
	switch (token[i])
	{
	case TOK_FUNCTION:
	LOG("TOK_FUNCTION");
	break;
	case TOK_CONST:
	LOG("TOK_CONST");
	break;
	case TOK_OPER:
	LOG("TOK_OPER");
	break;
	case TOK_STRING:
	LOG("TOK_STRING");
	break;
	case TOK_OPENP:
	LOG("TOK_OPENP");
	break;
	case TOK_CLOSEP:
	LOG("TOK_CLOSEP");
	break;
	case TOK_UNKNOWN:
	LOG("TOK_UNKNOWN");
	break;
	case TOK_INVALID:
	LOG("TOK_INVALID");
	break;
	case TOK_ERROR:
	LOG("TOK_ERROR");
	break;
	case TOK_END:
	LOG("TOK_END");
	break;
	case TOK_OPENB:
	LOG("TOK_OPENB");
	break;
	case TOK_CLOSEB:
	LOG("TOK_CLOSEB");
	break;
	}
	i++;
	}
	check_grammar(token);
	*/     //free(token);
	//exit(0);
}

void parse_script(const unsigned char * script)
{
	char *point = 0;
	char buf[1000] = "";
	char *buffer;
	char func_name[30] = "";
	char var_name[30] = "";
	char *block;
	int parn = 1;
	char *msg;
	point = (unsigned char *)script;

	buffer = buf;

	for (; *point; *point++)
	{
		switch (*point)
		{
		case '#':
		case '%':
			state = SC_FUN;
			continue;
			break;
		case '@':
			state = SC_VAR;
			continue;
			break;
		case '\n':
			continue;
			break;
		case ' ':
			continue;
			break;
		default:
			break;
		}
		if (state == SC_FUN)
		{
			func_name[0] = '\0';
			for (; *point; *point++)
			{
				*buffer = *point;

				if (*point == ' ' || *point == '(' || *point == '\n')
					break;

				strcat(func_name, buffer);
			}
			if (is_function(func_name) == -1) /* NOT a function..for some reason */
			{
				func_name[0] = '\0';
				continue;
			}
			if (!strcmp(func_name, "if"))
			{
				// handle if statements here
				block = (char*)malloc(2056 * sizeof(char*));

				for (; *point; *point++)
					if (*point == '(')
					{
						point++;
						break;
					}

				strcat(block, "(");
				for (; *point; *point++)
				{
					*buffer = *point;

					if (*point == '(')
						parn++;
					if (*point == ')')
						parn--;

					if (parn == 0)
					{
						strcat(block, ")");
						do_if(block, TRUE, NULL, NULL);
						free(block);
						break;
					}
					strcat(block, buffer);
				}

				if (parn >= 1)
				{
					msg = malloc(sizeof(char) * (strlen(block) + 400));
					sprintf(msg, "Script if statement incorrect. Matching parenthesis are not present. Present block: \"%s\". nNumber of missing parenthesis: %d", block, parn);
					give_term_echo(msg);
					free(msg);
					continue;
				}
				free(block);
				state = SC_NORM;
				continue;
			}
			else
			{
				// grab commands here, and grab arguments.
			}

			state = SC_NORM;
			continue;
		}

		if (state == SC_VAR)
		{
			for (; *point; *point++)
			{
				if (*point == ' ' || *point == '(' || *point == '\n' || *point == '=' || *point == ',' || *point == ')')
					break;
				*buffer = *point;
				strcat(var_name, buffer);
			}

			var_name[0] = '\0';
			state = SC_NORM;
			continue;
		}
	}
}

void save_aliases(FILE *fp)
{
	AL *alias;

	if (fp == NULL)
	{
		GiveError("Script file is either corrupt, or missing. Please check this file. NanoMUD's saving of scripts will now abort.", FALSE);
		return;
	}

	alias = aliaslist;
	if (alias == NULL)
		return;
	for (alias = aliaslist; alias != NULL; alias = alias->next)
	{
		fprintf(fp, "#alias {%s} {%s} {%s}\n", alias->name, alias->script, alias->cl == NULL ? "0" : alias->cl->name);
	}

	return;
}

void save_triggers(FILE *fp)
{
	TR *trigger;

	if (fp == NULL)
	{
		GiveError("Script file is either corrupt, or missing. Please check this file. NanoMUD's saving of scripts will now abort.", FALSE);
		return;
	}

	trigger = triggerlist;
	if (trigger == NULL)
		return;
	for (trigger = triggerlist; trigger != NULL; trigger = trigger->next)
	{
		fprintf(fp, "#trigger {%s} {%s} {%s}\n", trigger->name, trigger->script, trigger->cl == NULL ? "(null)" : trigger->cl->name);
	}

	return;
}

void save_paths(FILE *fp)
{
	PA *path;

	if (fp == NULL)
	{
		GiveError("Script file is either corrupt, or missing. Please check this file. NanoMUD's saving of scripts will now abort.", FALSE);
		return;
	}

	path = pathlist;
	if (path == NULL)
		return;
	for (path = pathlist; path != NULL; path = path->next)
	{
		fprintf(fp, "#path {%s} {%s} {%s}\n", path->name, path->script, path->cl == NULL ? "0" : path->cl->name);
	}

	return;
}

void save_macros(FILE *fp)
{
	MC *macro;

	if (fp == NULL)
	{
		GiveError("Script file is either corrupt, or missing. Please check this file. NanoMUD's saving of scripts will now abort.", FALSE);
		return;
	}

	macro = macrolist;
	if (macro == NULL)
		return;

	for (macro = macrolist; macro != NULL; macro = macro->next)
	{
		fprintf(fp, "#macro {%s} {%s} {%s}\n", macro->name, macro->script, macro->cl == NULL ? "(null)" : macro->cl->name);
	}

	return;
}

void save_vars(FILE *fp)
{
	VR *var;

	if (fp == NULL)
	{
		GiveError("Script file is either corrupt, or missing. Please check this file. NanoMUD's saving of scripts will now abort.", FALSE);
		return;
	}

	var = varlist;
	if (var == NULL)
		return;

	for (var = varlist; var != NULL; var = var->next)
	{
		fprintf(fp, "#var {%s} {%s} {%s}\n", var->name, var->script, var->cl == NULL ? "(null)" : var->cl->name);
	}

	return;
}

void save_scripts(void)
{
	FILE *fp;

	if ((fp = fopen("c:\\nanobit\\nanomud_scripts.txt", "w")) == NULL)
	{
		GiveError("Unable to open Scripts file.", FALSE);
		return;
	}
	save_aliases(fp);
	save_triggers(fp);
	save_paths(fp);
	save_macros(fp);
	save_vars(fp);
	fclose(fp);
	return;
}

void load_scripts(void)
{
	FILE *fp;
	int ret;
	char temp[5000];
	char buf[6000];
	PA *path;
	AL *alias;
	int p, a;

	p = a = 0;

	if ((fp = fopen("c:\\nanobit\\nanomud_scripts.txt", "r")) == NULL)
	{
		give_term_echo("Unable to open Scripts file for reading.");
		return;
	}

	while ((ret = read_string(temp, fp, 5000)) > -1)
	{
		temp[ret] = '\0';

		handle_input(temp);
		temp[0] = '\0';
		buf[0] = '\0';
	}
	fclose(fp);

	for (path = pathlist; path; path = path->next)
	{
		p++;
	}
	for (alias = aliaslist; alias; alias = alias->next)
	{
		a++;
	}

	give_term_info("Scripts loading is complete. [%d] Aliases, [%d] Paths loaded successfully", p, a);
}